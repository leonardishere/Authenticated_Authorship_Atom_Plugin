// Generated by IcedCoffeeScript 1.10.0
(function() {
  var BaseServer, ChainTail, DbTx, E, Leaf, LegacyUidTree, Lock, MNT, MerkleBaseDbTree, MerkleMainDbTree, Merkled, OnlineNotaryShellOut, SHA256, SHA512, UnwrappingTransport, a_json_parse, athrow, btcjs, chain_err, cnstmod, constants, createHash, deq, iutils, log, make_esc, merkle, mm, nodemailer, pgpu, prng, proofs, ref, ref1, ref2, ref3, ref4, ref5, rpc, run, sc, sig_id_to_sig_id_base, unix_time, update_processed_txids,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

var iced = (function() {
  function require(path){ return require[path]; }
  require['./const'] = (function() {
  var exports = {}, module = {exports: exports};
  // Generated by CoffeeScript 1.10.0
(function() {
  module.exports = {
    k: "__iced_k",
    k_noop: "__iced_k_noop",
    param: "__iced_p_",
    ns: "iced",
    runtime: "runtime",
    Deferrals: "Deferrals",
    deferrals: "__iced_deferrals",
    fulfill: "_fulfill",
    b_while: "_break",
    t_while: "_while",
    c_while: "_continue",
    n_while: "_next",
    n_arg: "__iced_next_arg",
    defer_method: "defer",
    slot: "__slot",
    assign_fn: "assign_fn",
    autocb: "autocb",
    retslot: "ret",
    trace: "__iced_trace",
    passed_deferral: "__iced_passed_deferral",
    findDeferral: "findDeferral",
    lineno: "lineno",
    parent: "parent",
    filename: "filename",
    funcname: "funcname",
    catchExceptions: 'catchExceptions',
    runtime_modes: ["node", "inline", "window", "none", "browserify", "interp"],
    trampoline: "trampoline",
    context: "context",
    defer_arg: "__iced_defer_",
    iterator: "__iced_it",
    await_exit: "await_exit"
  };

}).call(this);

  return module.exports;
})();require['./runtime'] = (function() {
  var exports = {}, module = {exports: exports};
  // Generated by CoffeeScript 1.10.0
(function() {
  var C, Deferrals, Rendezvous, __active_trace, __c, _trace_to_string, exceptionHandler, findDeferral, make_defer_return, stackWalk, tick_counter, trampoline, warn,
    slice = [].slice;

  C = require('./const');

  make_defer_return = function(obj, defer_args, id, trace_template, multi) {
    var k, ret, trace, v;
    trace = {};
    for (k in trace_template) {
      v = trace_template[k];
      trace[k] = v;
    }
    trace[C.lineno] = defer_args != null ? defer_args[C.lineno] : void 0;
    ret = function() {
      var inner_args, o, ref;
      inner_args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (defer_args != null) {
        if ((ref = defer_args.assign_fn) != null) {
          ref.apply(null, inner_args);
        }
      }
      if (obj) {
        o = obj;
        if (!multi) {
          obj = null;
        }
        return o._fulfill(id, trace);
      } else {
        return warn("overused deferral at " + (_trace_to_string(trace)));
      }
    };
    ret[C.trace] = trace;
    return ret;
  };

  __c = 0;

  tick_counter = function(mod) {
    __c++;
    if ((__c % mod) === 0) {
      __c = 0;
      return true;
    } else {
      return false;
    }
  };

  __active_trace = null;

  _trace_to_string = function(tr) {
    var fn;
    fn = tr[C.funcname] || "<anonymous>";
    return fn + " (" + tr[C.filename] + ":" + (tr[C.lineno] + 1) + ")";
  };

  warn = function(m) {
    return typeof console !== "undefined" && console !== null ? console.error("ICED warning: " + m) : void 0;
  };

  exports.trampoline = trampoline = function(fn) {
    if (!tick_counter(500)) {
      return fn();
    } else if ((typeof process !== "undefined" && process !== null ? process.nextTick : void 0) != null) {
      return process.nextTick(fn);
    } else {
      return setTimeout(fn);
    }
  };

  exports.Deferrals = Deferrals = (function() {
    function Deferrals(iterator, trace1) {
      this.iterator = iterator;
      this.trace = trace1;
      this.count = 0;
      this.ret = null;
      this.yielded = false;
    }

    Deferrals.prototype._call = function(trace) {
      var i;
      if (this.iterator) {
        __active_trace = trace;
        i = this.iterator;
        this.iterator = null;
        if (this.yielded) {
          return i.next(this.ret);
        }
      } else {
        return warn("Entered dead await at " + (_trace_to_string(trace)));
      }
    };

    Deferrals.prototype._fulfill = function(id, trace) {
      if (--this.count <= 0) {
        return this._call(trace);
      }
    };

    Deferrals.prototype.await_exit = function() {
      if (this.count === 0) {
        this.iterator = null;
        return false;
      } else {
        this.yielded = true;
        return true;
      }
    };

    Deferrals.prototype.defer = function(args) {
      var self;
      this.count++;
      self = this;
      return make_defer_return(self, args, null, this.trace);
    };

    return Deferrals;

  })();

  exports.findDeferral = findDeferral = function(args) {
    var a, j, len;
    for (j = 0, len = args.length; j < len; j++) {
      a = args[j];
      if (a != null ? a[C.trace] : void 0) {
        return a;
      }
    }
    return null;
  };

  exports.Rendezvous = Rendezvous = (function() {
    var RvId;

    function Rendezvous() {
      this.completed = [];
      this.waiters = [];
      this.defer_id = 0;
    }

    RvId = (function() {
      function RvId(rv, id1, multi1) {
        this.rv = rv;
        this.id = id1;
        this.multi = multi1;
      }

      RvId.prototype.defer = function(defer_args) {
        return this.rv._defer_with_id(this.id, defer_args, this.multi);
      };

      return RvId;

    })();

    Rendezvous.prototype.wait = function(cb) {
      var x;
      if (this.completed.length) {
        x = this.completed.shift();
        return cb(x);
      } else {
        return this.waiters.push(cb);
      }
    };

    Rendezvous.prototype.defer = function(defer_args) {
      var id;
      id = this.defer_id++;
      return this._defer_with_id(id, defer_args);
    };

    Rendezvous.prototype.id = function(i, multi) {
      multi = !!multi;
      return new RvId(this, i, multi);
    };

    Rendezvous.prototype._fulfill = function(id, trace) {
      var cb;
      if (this.waiters.length) {
        cb = this.waiters.shift();
        return cb(id);
      } else {
        return this.completed.push(id);
      }
    };

    Rendezvous.prototype._defer_with_id = function(id, defer_args, multi) {
      this.count++;
      return make_defer_return(this, defer_args, id, {}, multi);
    };

    return Rendezvous;

  })();

  exports.stackWalk = stackWalk = function(cb) {
    var line, ref, ret, tr;
    ret = [];
    tr = cb ? cb[C.trace] : __active_trace;
    while (tr) {
      line = "   at " + (_trace_to_string(tr));
      ret.push(line);
      tr = tr != null ? (ref = tr[C.parent]) != null ? ref[C.trace] : void 0 : void 0;
    }
    return ret;
  };

  exports.exceptionHandler = exceptionHandler = function(err, logger) {
    var stack;
    if (!logger) {
      logger = console.error;
    }
    logger(err.stack);
    stack = stackWalk();
    if (stack.length) {
      logger("Iced 'stack' trace (w/ real line numbers):");
      return logger(stack.join("\n"));
    }
  };

  exports.catchExceptions = function(logger) {
    return typeof process !== "undefined" && process !== null ? process.on('uncaughtException', function(err) {
      exceptionHandler(err, logger);
      return process.exit(1);
    }) : void 0;
  };

}).call(this);

  return module.exports;
})();require['./library'] = (function() {
  var exports = {}, module = {exports: exports};
  // Generated by CoffeeScript 1.10.0
(function() {
  var C, Pipeliner, _iand, _ior, _timeout, iced,
    slice = [].slice;



  C = require('./const');

  exports.iced = iced = require('./runtime');

  _timeout = function(cb, t, res, tmp) {
    var __iced_it, __iced_passed_deferral;
    __iced_passed_deferral = iced.findDeferral(arguments);
    __iced_it = (function(_this) {
      var arr, rv, which;
      return function*() {
        var __iced_deferrals;
        rv = new iced.Rendezvous;
        tmp[0] = rv.id(true).defer({
          assign_fn: (function() {
            return function() {
              return arr = slice.call(arguments, 0);
            };
          })(),
          lineno: 20,
          context: __iced_deferrals
        });
        setTimeout(rv.id(false).defer({
          lineno: 21,
          context: __iced_deferrals
        }), t);
        __iced_deferrals = new iced.Deferrals(__iced_it, {
          parent: __iced_passed_deferral
        });
        rv.wait(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return which = arguments[0];
            };
          })(),
          lineno: 22
        }));
        if (__iced_deferrals.await_exit()) {
          yield;
        }
        if (res) {
          res[0] = which;
        }
        return cb.apply(null, arr);
      };
    })(this)();
    return __iced_it.next();
  };

  exports.timeout = function(cb, t, res) {
    var tmp;
    tmp = [];
    _timeout(cb, t, res, tmp);
    return tmp[0];
  };

  _iand = function(cb, res, tmp) {
    var __iced_it, __iced_passed_deferral;
    __iced_passed_deferral = iced.findDeferral(arguments);
    __iced_it = (function(_this) {
      var ok;
      return function*() {
        var __iced_deferrals;
        __iced_deferrals = new iced.Deferrals(__iced_it, {
          parent: __iced_passed_deferral
        });
        tmp[0] = __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return ok = arguments[0];
            };
          })(),
          lineno: 39
        });
        if (__iced_deferrals.await_exit()) {
          yield;
        }
        if (!ok) {
          res[0] = false;
        }
        return cb();
      };
    })(this)();
    return __iced_it.next();
  };

  exports.iand = function(cb, res) {
    var tmp;
    tmp = [];
    _iand(cb, res, tmp);
    return tmp[0];
  };

  _ior = function(cb, res, tmp) {
    var __iced_it, __iced_passed_deferral;
    __iced_passed_deferral = iced.findDeferral(arguments);
    __iced_it = (function(_this) {
      var ok;
      return function*() {
        var __iced_deferrals;
        __iced_deferrals = new iced.Deferrals(__iced_it, {
          parent: __iced_passed_deferral
        });
        tmp[0] = __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return ok = arguments[0];
            };
          })(),
          lineno: 58
        });
        if (__iced_deferrals.await_exit()) {
          yield;
        }
        if (ok) {
          res[0] = true;
        }
        return cb();
      };
    })(this)();
    return __iced_it.next();
  };

  exports.ior = function(cb, res) {
    var tmp;
    tmp = [];
    _ior(cb, res, tmp);
    return tmp[0];
  };

  exports.Pipeliner = Pipeliner = (function() {
    function Pipeliner(window, delay) {
      this.window = window || 1;
      this.delay = delay || 0;
      this.queue = [];
      this.n_out = 0;
      this.cb = null;
      this[C.deferrals] = this;
      this["defer"] = this._defer;
    }

    Pipeliner.prototype.waitInQueue = function(cb) {
      var __iced_it, __iced_passed_deferral;
      __iced_passed_deferral = iced.findDeferral(arguments);
      __iced_it = (function(_this) {
        return function*() {
          var __iced_deferrals, __iced_deferrals1;
          while (_this.n_out >= _this.window) {
            __iced_deferrals = new iced.Deferrals(__iced_it, {
              parent: __iced_passed_deferral,
              funcname: "Pipeliner.waitInQueue"
            });
            _this.cb = __iced_deferrals.defer({
              lineno: 100
            });
            if (__iced_deferrals.await_exit()) {
              yield;
            }
          }
          _this.n_out++;
          if (_this.delay) {
            __iced_deferrals1 = new iced.Deferrals(__iced_it, {
              parent: __iced_passed_deferral,
              funcname: "Pipeliner.waitInQueue"
            });
            setTimeout(__iced_deferrals1.defer({
              lineno: 108
            }), _this.delay);
            if (__iced_deferrals1.await_exit()) {
              yield;
            }
          }
          return cb();
        };
      })(this)();
      return __iced_it.next();
    };

    Pipeliner.prototype.__defer = function(out, deferArgs) {
      var __iced_it, __iced_passed_deferral;
      __iced_passed_deferral = iced.findDeferral(arguments);
      __iced_it = (function(_this) {
        var tmp, voidCb;
        return function*() {
          var __iced_deferrals;
          __iced_deferrals = new iced.Deferrals(__iced_it, {
            parent: __iced_passed_deferral,
            funcname: "Pipeliner.__defer"
          });
          voidCb = __iced_deferrals.defer({
            lineno: 122
          });
          out[0] = function() {
            var args, ref;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            if ((ref = deferArgs.assign_fn) != null) {
              ref.apply(null, args);
            }
            return voidCb();
          };
          if (__iced_deferrals.await_exit()) {
            yield;
          }
          _this.n_out--;
          if (_this.cb) {
            tmp = _this.cb;
            _this.cb = null;
            return tmp();
          }
        };
      })(this)();
      return __iced_it.next();
    };

    Pipeliner.prototype._defer = function(deferArgs) {
      var tmp;
      tmp = [];
      this.__defer(tmp, deferArgs);
      return tmp[0];
    };

    Pipeliner.prototype.flush = function(cb) {
      var __iced_it, __iced_passed_deferral;
      __iced_passed_deferral = iced.findDeferral(arguments);
      __iced_it = (function(_this) {
        return function*() {
          var __iced_deferrals;
          while (_this.n_out) {
            __iced_deferrals = new iced.Deferrals(__iced_it, {
              parent: __iced_passed_deferral,
              funcname: "Pipeliner.flush"
            });
            _this.cb = __iced_deferrals.defer({
              lineno: 151
            });
            if (__iced_deferrals.await_exit()) {
              yield;
            }
          }
          return cb();
        };
      })(this)();
      return __iced_it.next();
    };

    return Pipeliner;

  })();

}).call(this);

  return module.exports;
})();require['./main'] = (function() {
  var exports = {}, module = {exports: exports};
  // Generated by CoffeeScript 1.10.0
(function() {
  var i, k, len, mod, mods, v;

  exports["const"] = require('./const');

  mods = [require('./runtime'), require('./library')];

  for (i = 0, len = mods.length; i < len; i++) {
    mod = mods[i];
    for (k in mod) {
      v = mod[k];
      exports[k] = v;
    }
  }

}).call(this);

  return module.exports;
})();
  return require['./main'];
}());;


  ref = require("../lib/rpcsrv_base"), BaseServer = ref.BaseServer, run = ref.run;

  cnstmod = require("../lib/constants");

  constants = cnstmod.constants;

  sc = cnstmod.status.codes;

  mm = require('../lib/mod').mgr;

  log = require('../lib/log');

  nodemailer = require('nodemailer');

  ref1 = require('crypto'), prng = ref1.prng, createHash = ref1.createHash;

  DbTx = require('../lib/mod/db').Tx;

  iutils = require('iced-utils');

  Lock = iutils.lock.Lock;

  ref2 = iutils.util, athrow = ref2.athrow, unix_time = ref2.unix_time, a_json_parse = ref2.a_json_parse;

  ref3 = require('iced-error'), chain_err = ref3.chain_err, make_esc = ref3.make_esc;

  MNT = constants.merkle_node_types;

  deq = require('deep-equal');

  merkle = require('merkle-tree');

  OnlineNotaryShellOut = require('../lib/notary').OnlineNotaryShellOut;

  E = require('../lib/err').E;

  proofs = require('keybase-proofs');

  btcjs = require('keybase-bitcoinjs-lib');

  pgpu = require('pgp-utils');

  ref4 = require('../lib/keyutils'), sig_id_to_sig_id_base = ref4.sig_id_to_sig_id_base, SHA512 = ref4.SHA512, SHA256 = ref4.SHA256;

  ref5 = require('libkeybase').merkle.leaf, ChainTail = ref5.ChainTail, Leaf = ref5.Leaf;

  rpc = require('framed-msgpack-rpc');

  update_processed_txids = function(arg) {
    var args, dbtx, i, q, qm, txids;
    dbtx = arg.dbtx, txids = arg.txids;
    qm = ((function() {
      var j, len, results;
      results = [];
      for (j = 0, len = txids.length; j < len; j++) {
        i = txids[j];
        results.push("?");
      }
      return results;
    })()).join(",");
    q = "UPDATE merkle_work_list SET ptime=NOW(), status=? WHERE txid IN (" + qm + ")";
    args = [constants.merkle_tx_status.PROCESSED].concat(txids);
    return dbtx.push(q, args);
  };

  MerkleBaseDbTree = (function(superClass) {
    extend(MerkleBaseDbTree, superClass);

    function MerkleBaseDbTree() {
      MerkleBaseDbTree.__super__.constructor.call(this, {
        config: new merkle.Config(mm.config.merkle)
      });
      this._nodes = {};
      this._root = null;
      this._root_lock = new Lock;
    }

    MerkleBaseDbTree.prototype.store_node = function(arg, cb) {
      var __iced_it, __iced_passed_deferral, key, obj, obj_s;
      key = arg.key, obj = arg.obj, obj_s = arg.obj_s;
      __iced_passed_deferral = iced.findDeferral(arguments);
      __iced_it = (function(_this) {
        var args, err, q, tx;
        return function*() {
          var __iced_deferrals;
          tx = new DbTx;
          obj_s || (obj_s = JSS(obj));
          q = "INSERT IGNORE INTO merkle_blocks(hash, val, ctime, type)\nVALUES(?,?,NOW(),?)";
          args = [key, obj_s, obj.type];
          tx.push(q, args);
          q = "SELECT val, type FROM merkle_blocks WHERE hash=?";
          args = [key];
          tx.push(q, args, {
            name: "replace",
            assertion: function(rows) {
              return (rows[0].val === obj_s) && (rows[0].type === obj.type);
            }
          });
          __iced_deferrals = new iced.Deferrals(__iced_it, {
            parent: __iced_passed_deferral,
            funcname: "MerkleBaseDbTree.store_node"
          });
          mm.db.transaction({
            tx: tx
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 67
          }));
          if (__iced_deferrals.await_exit()) {
            yield;
          }
          if (err == null) {
            _this._nodes[key] = obj;
          }
          return cb(err);
        };
      })(this)();
      return __iced_it.next();
    };

    MerkleBaseDbTree.prototype.lookup_node = function(arg, cb) {
      var __iced_it, __iced_passed_deferral, key;
      key = arg.key;
      __iced_passed_deferral = iced.findDeferral(arguments);
      __iced_it = (function(_this) {
        var args, esc, q, ret, row;
        return function*() {
          var __iced_deferrals, __iced_deferrals1;
          esc = make_esc(cb, "MerkleDbTree::lookup_node");
          ret = _this._nodes[key];
          if (ret == null) {
            q = "SELECT val,type FROM merkle_blocks WHERE hash=?";
            args = [key];
            __iced_deferrals = new iced.Deferrals(__iced_it, {
              parent: __iced_passed_deferral,
              funcname: "MerkleBaseDbTree.lookup_node"
            });
            mm.db.load1({
              q: q,
              args: args
            }, esc(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return row = arguments[0];
                };
              })(),
              lineno: 80
            })));
            if (__iced_deferrals.await_exit()) {
              yield;
            }
            __iced_deferrals1 = new iced.Deferrals(__iced_it, {
              parent: __iced_passed_deferral,
              funcname: "MerkleBaseDbTree.lookup_node"
            });
            a_json_parse(row.val, esc(__iced_deferrals1.defer({
              assign_fn: (function() {
                return function() {
                  return ret = arguments[0];
                };
              })(),
              lineno: 81
            })));
            if (__iced_deferrals1.await_exit()) {
              yield;
            }
            _this._nodes[key] = ret;
          }
          return cb(null, ret);
        };
      })(this)();
      return __iced_it.next();
    };

    return MerkleBaseDbTree;

  })(merkle.Base);

  LegacyUidTree = (function(superClass) {
    extend(LegacyUidTree, superClass);

    function LegacyUidTree() {
      return LegacyUidTree.__super__.constructor.apply(this, arguments);
    }

    LegacyUidTree.prototype.commit_root = function(arg, cb) {
      var __iced_it, __iced_passed_deferral, key, prev_root, txinfo;
      key = arg.key, txinfo = arg.txinfo, prev_root = arg.prev_root;
      __iced_passed_deferral = iced.findDeferral(arguments);
      __iced_it = (function(_this) {
        var args, err, q;
        return function*() {
          var __iced_deferrals, __iced_deferrals1;
          log.info("+ commit root");
          __iced_deferrals = new iced.Deferrals(__iced_it, {
            parent: __iced_passed_deferral,
            funcname: "LegacyUidTree.commit_root"
          });
          _this._root_lock.acquire(__iced_deferrals.defer({
            lineno: 94
          }));
          if (__iced_deferrals.await_exit()) {
            yield;
          }
          q = "INSERT INTO legacy_uid_tree_root(hash,ctime) VALUES(?,NOW())";
          args = [key];
          __iced_deferrals1 = new iced.Deferrals(__iced_it, {
            parent: __iced_passed_deferral,
            funcname: "LegacyUidTree.commit_root"
          });
          mm.db.update1({
            q: q,
            args: args,
            insert_or_update: true
          }, __iced_deferrals1.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 98
          }));
          if (__iced_deferrals1.await_exit()) {
            yield;
          }
          _this._root = key;
          _this._root_lock.release();
          log.info("- commit root");
          return cb(err);
        };
      })(this)();
      return __iced_it.next();
    };

    LegacyUidTree.prototype.lookup_root = function(cb) {
      log.info("Building from scratch in LegacyUidTree::lookup_root");
      return cb(null, "00");
    };

    LegacyUidTree.prototype.hash_fn = function(s) {
      return SHA256(s, 'hex');
    };

    return LegacyUidTree;

  })(MerkleBaseDbTree);

  MerkleMainDbTree = (function(superClass) {
    extend(MerkleMainDbTree, superClass);

    function MerkleMainDbTree() {
      MerkleMainDbTree.__super__.constructor.call(this);
      this._notary = null;
      this._kbfs = {
        "public": {
          root: null,
          version: null
        },
        "private": {
          root: null,
          version: null
        }
      };
    }

    MerkleMainDbTree.prototype.set_notary = function(n) {
      return this._notary = n;
    };

    MerkleMainDbTree.prototype.hash_fn = function(s) {
      return SHA512(s, 'hex');
    };

    MerkleMainDbTree.prototype.lookup_root = function(cb) {
      var __iced_it, __iced_passed_deferral;
      __iced_passed_deferral = iced.findDeferral(arguments);
      __iced_it = (function(_this) {
        var args, err, q, ret, rows;
        return function*() {
          var __iced_deferrals, __iced_deferrals1;
          err = null;
          ret = _this._root;
          if (ret == null) {
            __iced_deferrals = new iced.Deferrals(__iced_it, {
              parent: __iced_passed_deferral,
              funcname: "MerkleMainDbTree.lookup_root"
            });
            _this._root_lock.acquire(__iced_deferrals.defer({
              lineno: 148
            }));
            if (__iced_deferrals.await_exit()) {
              yield;
            }
            q = "SELECT hash FROM merkle_roots AS a\nINNER JOIN (SELECT MAX(seqno) AS q FROM merkle_roots) AS b\nON a.seqno = b.q";
            args = [];
            __iced_deferrals1 = new iced.Deferrals(__iced_it, {
              parent: __iced_passed_deferral,
              funcname: "MerkleMainDbTree.lookup_root"
            });
            mm.db.query({
              q: q,
              args: args
            }, __iced_deferrals1.defer({
              assign_fn: (function() {
                return function() {
                  err = arguments[0];
                  return rows = arguments[1];
                };
              })(),
              lineno: 153
            }));
            if (__iced_deferrals1.await_exit()) {
              yield;
            }
            if (err != null) {
              log.warn("Error in lookup root: " + err);
            } else if (rows.length === 0) {
              _this._root = ret = "00";
              log.warn("No previous root; rebuilding from scratch");
            } else {
              _this._root = ret = rows[0].hash;
            }
            _this._root_lock.release();
          }
          log.info("| lookup root -> " + ret);
          return cb(err, ret);
        };
      })(this)();
      return __iced_it.next();
    };

    MerkleMainDbTree.prototype.sign_root = function(arg, cb) {
      var __iced_it, __iced_passed_deferral, ctime, hash, prev, seqno, txid;
      hash = arg.hash, txid = arg.txid, ctime = arg.ctime, seqno = arg.seqno, prev = arg.prev;
      __iced_passed_deferral = iced.findDeferral(arguments);
      __iced_it = (function(_this) {
        var dur, err, esc, json, json_s, m, sig, sig_hash160, start;
        return function*() {
          var __iced_deferrals, __iced_deferrals1, __iced_deferrals2, ref6;
          esc = make_esc(cb, "MerkleDbTree::sign_root");
          start = Date.now();
          log.info("+ sign root");
          sig = json_s = null;
          if (!_this._notary) {
            err = new E.NoPrivateKeyError("didn't initialize with a notary");
            __iced_deferrals = new iced.Deferrals(__iced_it, {
              parent: __iced_passed_deferral,
              funcname: "MerkleMainDbTree.sign_root"
            });
            athrow(err, esc(__iced_deferrals.defer({
              lineno: 174
            })));
            if (__iced_deferrals.await_exit()) {
              yield;
            }
          }
          json = {
            ctime: ctime,
            tag: proofs.constants.tags.sig,
            body: {
              version: proofs.constants.versions.sig,
              type: "merkle_root",
              txid: txid,
              root: hash,
              seqno: seqno,
              prev: prev,
              legacy_uid_root: _this._legacy_uid_root,
              kbfs: _this._kbfs
            }
          };
          log.info("| sign " + (JSON.stringify(json)));
          __iced_deferrals1 = new iced.Deferrals(__iced_it, {
            parent: __iced_passed_deferral,
            funcname: "MerkleMainDbTree.sign_root"
          });
          _this._notary.sign({
            json: json
          }, __iced_deferrals1.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                sig = arguments[1];
                return json_s = arguments[2];
              };
            })(),
            lineno: 188
          }));
          if (__iced_deferrals1.await_exit()) {
            yield;
          }
          ref6 = pgpu.armor.decode(sig), err = ref6[0], m = ref6[1];
          if (err != null) {
            __iced_deferrals2 = new iced.Deferrals(__iced_it, {
              parent: __iced_passed_deferral,
              funcname: "MerkleMainDbTree.sign_root"
            });
            athrow(err, esc(__iced_deferrals2.defer({
              lineno: 190
            })));
            if (__iced_deferrals2.await_exit()) {
              yield;
            }
          }
          sig_hash160 = btcjs.crypto.hash160(m.body);
          dur = Date.now() - start;
          log.info("- sign root (" + dur + "ms)");
          return cb(null, sig, json_s, sig_hash160);
        };
      })(this)();
      return __iced_it.next();
    };

    MerkleMainDbTree.prototype.commit_root = function(arg, cb) {
      var __iced_it, __iced_passed_deferral, key, prev_root, txinfo;
      key = arg.key, txinfo = arg.txinfo, prev_root = arg.prev_root;
      __iced_passed_deferral = iced.findDeferral(arguments);
      __iced_it = (function(_this) {
        var args, ctime, err, esc, json_s, last_txid, prev_seqno, q, row, seqno, sig, sig_hash160, sign_err, tx, txids;
        return function*() {
          var __iced_deferrals, __iced_deferrals1, __iced_deferrals2, __iced_deferrals3;
          cb = chain_err(cb, function(tcb) {
            _this._root_lock.release();
            log.info("- commit root");
            return tcb();
          });
          esc = make_esc(cb, "MerkleDbTree::commit_root");
          err = null;
          txids = txinfo != null ? txinfo.txids : [];
          last_txid = txids.length ? txids.slice(-1)[0] : null;
          log.info("+ commit root");
          __iced_deferrals = new iced.Deferrals(__iced_it, {
            parent: __iced_passed_deferral,
            funcname: "MerkleMainDbTree.commit_root"
          });
          _this._root_lock.acquire(__iced_deferrals.defer({
            lineno: 214
          }));
          if (__iced_deferrals.await_exit()) {
            yield;
          }
          tx = new DbTx();
          q = "SELECT IFNULL(MAX(seqno),0) AS max_seqno FROM merkle_roots";
          args = [];
          __iced_deferrals1 = new iced.Deferrals(__iced_it, {
            parent: __iced_passed_deferral,
            funcname: "MerkleMainDbTree.commit_root"
          });
          mm.db.load1({
            q: q,
            args: args
          }, esc(__iced_deferrals1.defer({
            assign_fn: (function() {
              return function() {
                return row = arguments[0];
              };
            })(),
            lineno: 219
          })));
          if (__iced_deferrals1.await_exit()) {
            yield;
          }
          prev_seqno = row.max_seqno;
          seqno = prev_seqno + 1;
          ctime = unix_time();
          __iced_deferrals2 = new iced.Deferrals(__iced_it, {
            parent: __iced_passed_deferral,
            funcname: "MerkleMainDbTree.commit_root"
          });
          _this.sign_root({
            hash: key,
            txid: last_txid,
            ctime: ctime,
            seqno: seqno,
            prev: prev_root
          }, __iced_deferrals2.defer({
            assign_fn: (function() {
              return function() {
                sign_err = arguments[0];
                sig = arguments[1];
                json_s = arguments[2];
                return sig_hash160 = arguments[3];
              };
            })(),
            lineno: 226
          }));
          if (__iced_deferrals2.await_exit()) {
            yield;
          }
          if (sign_err != null) {
            log.warn("Error in signing merkle root: " + sign_err + "; skipping signature for now");
            sig = json_s = null;
          }
          q = "INSERT INTO merkle_roots(seqno, ctime, hash, txid, sig, payload_json, hash160)\nVALUES(?,FROM_UNIXTIME(?),?,?,?,?,?)";
          args = [seqno, ctime, key, last_txid, sig, json_s, sig_hash160.toString('hex')];
          tx.push(q, args);
          if (txinfo != null) {
            update_processed_txids({
              dbtx: tx,
              txids: txinfo.txids
            });
          }
          __iced_deferrals3 = new iced.Deferrals(__iced_it, {
            parent: __iced_passed_deferral,
            funcname: "MerkleMainDbTree.commit_root"
          });
          mm.db.transaction({
            tx: tx
          }, __iced_deferrals3.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 239
          }));
          if (__iced_deferrals3.await_exit()) {
            yield;
          }
          if (err != null) {
            log.error("Failed to commit root in merkle transaction: " + err);
          } else {
            _this._root = key;
            log.info("| commit root <- " + key);
          }
          return cb(err);
        };
      })(this)();
      return __iced_it.next();
    };

    return MerkleMainDbTree;

  })(MerkleBaseDbTree);

  exports.Server = Merkled = (function(superClass) {
    extend(Merkled, superClass);

    function Merkled() {
      this.update_kbfs_roots = bind(this.update_kbfs_roots, this);
      Merkled.__super__.constructor.call(this, mm.config.dist.srv.merkled);
      this._tree = null;
      this._notary = null;
    }

    Merkled.prototype.init1 = function(cb) {
      this._tree = new MerkleMainDbTree();
      return cb(null);
    };

    Merkled.prototype.select_all_user_chains_from_db = function(cb) {
      var __iced_it, __iced_passed_deferral;
      __iced_passed_deferral = iced.findDeferral(arguments);
      __iced_it = (function(_this) {
        var args, err, kid, leaf, list, payload_hash, pub, q, rows, seqno, sig_id, uid, users;
        return function*() {
          var __iced_deferrals;
          q = "SELECT k.uid, k.kid, s.sig_id, s.payload_hash, s.seqno\nFROM key_bundles AS k\n-- some users have no chain links, so we use LEFT OUTER JOINs\n-- to make sure we still get the eldest key in that case\nLEFT OUTER JOIN (\n  SELECT MAX(seqno) AS seqno, uid\n  FROM sig_seqnos\n  WHERE seqno_type=?\n  GROUP BY uid\n) AS tips\nUSING (uid)\nLEFT OUTER JOIN sig_seqnos AS s\nUSING (uid, seqno)\nWHERE (s.seqno_type=? OR s.seqno_type IS NULL) AND k.is_primary = 1 AND k.status = 0 AND k.key_type IN (?, ?);";
          args = [constants.seqno_types.PUBLIC, constants.seqno_types.PUBLIC, constants.key.key_type.OPEN_PGP_PUBLIC, constants.key.key_type.KB_NACL_EDDSA];
          __iced_deferrals = new iced.Deferrals(__iced_it, {
            parent: __iced_passed_deferral,
            funcname: "Merkled.select_all_user_chains_from_db"
          });
          mm.db.query({
            q: q,
            args: args
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return rows = arguments[1];
              };
            })(),
            lineno: 289
          }));
          if (__iced_deferrals.await_exit()) {
            yield;
          }
          list = null;
          if (err == null) {
            users = {};
            list = (function() {
              var j, len, ref6, results;
              results = [];
              for (j = 0, len = rows.length; j < len; j++) {
                ref6 = rows[j], uid = ref6.uid, payload_hash = ref6.payload_hash, seqno = ref6.seqno, sig_id = ref6.sig_id, kid = ref6.kid;
                if (users[uid] != null) {
                  err = new Error("duplicated user " + uid);
                  break;
                }
                users[uid] = true;
                if (seqno != null) {
                  pub = new ChainTail({
                    seqno: seqno,
                    payload_hash: payload_hash,
                    sig_id: sig_id_to_sig_id_base(sig_id)
                  });
                } else {
                  pub = null;
                }
                leaf = new Leaf({
                  eldest_kid: kid,
                  pub: pub
                });
                results.push([uid, leaf.to_json()]);
              }
              return results;
            })();
          }
          return cb(err, list);
        };
      })(this)();
      return __iced_it.next();
    };

    Merkled.prototype.unlock = function(cb) {
      this._lock.release();
      return cb(null);
    };

    Merkled.prototype.init_notary = function(cb) {
      var __iced_it, __iced_passed_deferral;
      __iced_passed_deferral = iced.findDeferral(arguments);
      __iced_it = (function(_this) {
        var conf, err;
        return function*() {
          var __iced_deferrals;
          conf = mm.config.keys.merkle;
          _this._notary = new OnlineNotaryShellOut({
            conf: conf
          });
          __iced_deferrals = new iced.Deferrals(__iced_it, {
            parent: __iced_passed_deferral,
            funcname: "Merkled.init_notary"
          });
          _this._notary.init({
            passphrase: conf.passphrase
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 330
          }));
          if (__iced_deferrals.await_exit()) {
            yield;
          }
          if (err != null) {
            log.error("Error loading Notary merkle signing key: " + err);
          } else {
            log.info("| Successful init of signing notary");
          }
          _this._tree.set_notary(_this._notary);
          return cb(err);
        };
      })(this)();
      return __iced_it.next();
    };

    Merkled.prototype.init2 = function(cb) {
      var __iced_it, __iced_passed_deferral;
      __iced_passed_deferral = iced.findDeferral(arguments);
      __iced_it = (function(_this) {
        var err, root;
        return function*() {
          var __iced_deferrals, __iced_deferrals1, __iced_deferrals2, __iced_deferrals3;
          __iced_deferrals = new iced.Deferrals(__iced_it, {
            parent: __iced_passed_deferral,
            funcname: "Merkled.init2"
          });
          _this.init_notary(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 341
          }));
          if (__iced_deferrals.await_exit()) {
            yield;
          }
          cb(err);
          if (err != null) {
            return;
          }
          __iced_deferrals1 = new iced.Deferrals(__iced_it, {
            parent: __iced_passed_deferral,
            funcname: "Merkled.init2"
          });
          _this.start_kbfs_root_loop(__iced_deferrals1.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 345
          }));
          if (__iced_deferrals1.await_exit()) {
            yield;
          }
          if (err != null) {
            log.warn("Error in start_kbfs_root_loop: " + err);
          }
          __iced_deferrals2 = new iced.Deferrals(__iced_it, {
            parent: __iced_passed_deferral,
            funcname: "Merkled.init2"
          });
          _this.init_legacy_uid_root(__iced_deferrals2.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return root = arguments[1];
              };
            })(),
            lineno: 349
          }));
          if (__iced_deferrals2.await_exit()) {
            yield;
          }
          if (err != null) {
            return log.warn("Error in initializing legacy UID tree: " + (err.toString()));
          } else {
            log.info("| legacy UID tree root @ " + root);
            _this._tree._legacy_uid_root = root;
            __iced_deferrals3 = new iced.Deferrals(__iced_it, {
              parent: __iced_passed_deferral,
              funcname: "Merkled.init2"
            });
            _this.full_build(__iced_deferrals3.defer({
              assign_fn: (function() {
                return function() {
                  return err = arguments[0];
                };
              })(),
              lineno: 355
            }));
            if (__iced_deferrals3.await_exit()) {
              yield;
            }
            if (err != null) {
              return log.warn("Error in full build: " + err);
            } else {
              log.info("| Full build finished");
              return _this.process_loop();
            }
          }
        };
      })(this)();
      return __iced_it.next();
    };

    Merkled.prototype.process_loop = function() {
      var __iced_it, __iced_passed_deferral;
      __iced_passed_deferral = iced.findDeferral(arguments);
      __iced_it = (function(_this) {
        return function*() {
          var __iced_deferrals, results;
          results = [];
          while (true) {
            __iced_deferrals = new iced.Deferrals(__iced_it, {
              parent: __iced_passed_deferral,
              funcname: "Merkled.process_loop"
            });
            _this.process_loop_1(__iced_deferrals.defer({
              lineno: 366
            }));
            if (__iced_deferrals.await_exit()) {
              yield;
            }
          }
          return results;
        };
      })(this)();
      return __iced_it.next();
    };

    Merkled.prototype.call_tx_wait_cb = function() {
      var c;
      if (this._tx_wait_cb != null) {
        c = this._tx_wait_cb;
        this._tx_wait_cb = null;
        return c();
      }
    };

    Merkled.prototype.tx_wait = function(arg, cb) {
      var __iced_it, __iced_passed_deferral, wait_ms;
      wait_ms = arg.wait_ms;
      __iced_passed_deferral = iced.findDeferral(arguments);
      __iced_it = (function(_this) {
        var rv, which;
        return function*() {
          var __iced_deferrals;
          if (_this._tx_wait_cb) {
            _this._tx_wait_cb = null;
          } else {
            log.info("+ tx_wait for " + wait_ms + "ms");
            rv = new iced.Rendezvous();
            setTimeout(rv.id(false).defer({
              lineno: 384,
              context: __iced_deferrals
            }), wait_ms);
            _this._tx_wait_cb = rv.id(true).defer({
              lineno: 385,
              context: __iced_deferrals
            });
            __iced_deferrals = new iced.Deferrals(__iced_it, {
              parent: __iced_passed_deferral,
              funcname: "Merkled.tx_wait"
            });
            rv.wait(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return which = arguments[0];
                };
              })(),
              lineno: 386
            }));
            if (__iced_deferrals.await_exit()) {
              yield;
            }
            log.info("- tx_wait finished; interrupt=" + which);
          }
          return cb();
        };
      })(this)();
      return __iced_it.next();
    };

    Merkled.prototype.process_transaction = function(arg, cb) {
      var __iced_it, __iced_passed_deferral, leaf_id, txids, val;
      txids = arg.txids, leaf_id = arg.leaf_id, val = arg.val;
      __iced_passed_deferral = iced.findDeferral(arguments);
      __iced_it = (function(_this) {
        var args, dbtx, err, root, txinfo;
        return function*() {
          var __iced_deferrals, __iced_deferrals1;
          txinfo = {
            txids: txids
          };
          args = {
            key: leaf_id,
            val: val,
            txinfo: txinfo
          };
          __iced_deferrals = new iced.Deferrals(__iced_it, {
            parent: __iced_passed_deferral,
            funcname: "Merkled.process_transaction"
          });
          _this._tree.upsert(args, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return root = arguments[1];
              };
            })(),
            lineno: 395
          }));
          if (__iced_deferrals.await_exit()) {
            yield;
          }
          if (err != null) {
            log.error("Error processing transaction " + (JSON.stringify(args)) + ": " + err);
          } else if (root == null) {
            dbtx = new DbTx();
            update_processed_txids({
              dbtx: dbtx,
              txids: txids
            });
            __iced_deferrals1 = new iced.Deferrals(__iced_it, {
              parent: __iced_passed_deferral,
              funcname: "Merkled.process_transaction"
            });
            mm.db.transaction({
              tx: dbtx
            }, __iced_deferrals1.defer({
              assign_fn: (function() {
                return function() {
                  return err = arguments[0];
                };
              })(),
              lineno: 401
            }));
            if (__iced_deferrals1.await_exit()) {
              yield;
            }
            if (err != null) {
              log.error("Error updating stale transactions: " + (err.toString()));
            } else {
              log.info("We already updated uid=" + leaf_id + " at TXID=" + (txids.join(',')) + "; marked processed");
            }
          } else {
            log.info("| Updated root to " + root);
          }
          return cb(err);
        };
      })(this)();
      return __iced_it.next();
    };

    Merkled.prototype.process_transactions = function(rows, cb) {
      var __iced_it, __iced_passed_deferral;
      __iced_passed_deferral = iced.findDeferral(arguments);
      __iced_it = (function(_this) {
        var err, k, obj, row, tab, tmp;
        return function*() {
          var __iced_deferrals, j, len;
          err = null;
          tab = {};
          for (j = 0, len = rows.length; j < len; j++) {
            row = rows[j];
            if ((obj = tab[row.leaf_id]) == null) {
              obj = {
                txids: []
              };
              tab[row.leaf_id] = obj;
            }
            obj.row = row;
            obj.txids.push(row.txid);
          }
          for (k in tab) {
            obj = tab[k];
            log.info("| Computing Leaf cluster for " + k);
            __iced_deferrals = new iced.Deferrals(__iced_it, {
              parent: __iced_passed_deferral,
              funcname: "Merkled.process_transactions"
            });
            _this.process_transaction({
              txids: obj.txids,
              leaf_id: k,
              val: obj.row.val
            }, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return tmp = arguments[0];
                };
              })(),
              lineno: 427
            }));
            if (__iced_deferrals.await_exit()) {
              yield;
            }
            if (tmp != null) {
              err = tmp;
            }
          }
          return cb(err);
        };
      })(this)();
      return __iced_it.next();
    };

    Merkled.prototype.process_loop_1 = function(cb) {
      var __iced_it, __iced_passed_deferral;
      __iced_passed_deferral = iced.findDeferral(arguments);
      __iced_it = (function(_this) {
        var cfg, err, n, rows;
        return function*() {
          var __iced_deferrals, __iced_deferrals1, __iced_deferrals2, __iced_deferrals3, __iced_deferrals4;
          cfg = mm.config.merkle.processor;
          log.info("+ process_loop_1");
          __iced_deferrals = new iced.Deferrals(__iced_it, {
            parent: __iced_passed_deferral,
            funcname: "Merkled.process_loop_1"
          });
          _this.read_from_queue({
            n: cfg.batch_size
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return rows = arguments[1];
              };
            })(),
            lineno: 436
          }));
          if (__iced_deferrals.await_exit()) {
            yield;
          }
          if (err != null) {
            log.error("Error reading from transaction queue: " + err);
            __iced_deferrals1 = new iced.Deferrals(__iced_it, {
              parent: __iced_passed_deferral,
              funcname: "Merkled.process_loop_1"
            });
            setTimeout(__iced_deferrals1.defer({
              lineno: 439
            }), cfg.db_error_wait);
            if (__iced_deferrals1.await_exit()) {
              yield;
            }
          } else {
            n = rows.length;
            log.info("| read " + n + " from queue");
            if (n === 0) {
              __iced_deferrals2 = new iced.Deferrals(__iced_it, {
                parent: __iced_passed_deferral,
                funcname: "Merkled.process_loop_1"
              });
              _this.tx_wait({
                wait_ms: cfg.long_wait
              }, __iced_deferrals2.defer({
                lineno: 444
              }));
              if (__iced_deferrals2.await_exit()) {
                yield;
              }
            } else {
              __iced_deferrals3 = new iced.Deferrals(__iced_it, {
                parent: __iced_passed_deferral,
                funcname: "Merkled.process_loop_1"
              });
              _this.process_transactions(rows, __iced_deferrals3.defer({
                assign_fn: (function() {
                  return function() {
                    return err = arguments[0];
                  };
                })(),
                lineno: 446
              }));
              if (__iced_deferrals3.await_exit()) {
                yield;
              }
              __iced_deferrals4 = new iced.Deferrals(__iced_it, {
                parent: __iced_passed_deferral,
                funcname: "Merkled.process_loop_1"
              });
              setTimeout(__iced_deferrals4.defer({
                lineno: 447
              }), cfg.short_wait);
              if (__iced_deferrals4.await_exit()) {
                yield;
              }
            }
          }
          log.info("- process_loop_1");
          return cb();
        };
      })(this)();
      return __iced_it.next();
    };

    Merkled.prototype.read_from_queue = function(arg, cb) {
      var __iced_it, __iced_passed_deferral, n, txid;
      n = arg.n, txid = arg.txid;
      __iced_passed_deferral = iced.findDeferral(arguments);
      __iced_it = (function(_this) {
        var args, e, err, out, q, row, rows;
        return function*() {
          var __iced_deferrals, j, len;
          q = "SELECT a.txid AS txid, a.leaf_id AS leaf_id, b.val AS val, a.status AS status\nFROM merkle_work_list AS a\nINNER JOIN merkle_leaf_transaction_log_2 AS b ON a.txid = b.txid\nWHERE status=?";
          args = [constants.merkle_tx_status.POSTED];
          if (txid != null) {
            q += " AND a.txid=?";
            args.push(txid);
          } else if (n != null) {
            q += " LIMIT ?";
            args.push(n);
          }
          out = null;
          __iced_deferrals = new iced.Deferrals(__iced_it, {
            parent: __iced_passed_deferral,
            funcname: "Merkled.read_from_queue"
          });
          mm.db.query({
            q: q,
            args: args
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return rows = arguments[1];
              };
            })(),
            lineno: 466
          }));
          if (__iced_deferrals.await_exit()) {
            yield;
          }
          if (err == null) {
            out = [];
            for (j = 0, len = rows.length; j < len; j++) {
              row = rows[j];
              try {
                row.val = JSON.parse(row.val);
              } catch (error) {
                e = error;
                log.warn("Bad JSON val in queue: " + (JSON.stringify(row)));
                continue;
              }
              out.push(row);
            }
          }
          return cb(err, out);
        };
      })(this)();
      return __iced_it.next();
    };

    Merkled.prototype.lookup_previous_checkpoint = function(cb) {
      var __iced_it, __iced_passed_deferral;
      __iced_passed_deferral = iced.findDeferral(arguments);
      __iced_it = (function(_this) {
        var args, err, q, ret, rows;
        return function*() {
          var __iced_deferrals;
          q = "SELECT seqno,btime,etime FROM merkle_build_checkpoints ORDER BY seqno DESC LIMIT 1";
          args = [];
          __iced_deferrals = new iced.Deferrals(__iced_it, {
            parent: __iced_passed_deferral,
            funcname: "Merkled.lookup_previous_checkpoint"
          });
          mm.db.query({
            q: q,
            args: args
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return rows = arguments[1];
              };
            })(),
            lineno: 484
          }));
          if (__iced_deferrals.await_exit()) {
            yield;
          }
          ret = rows != null ? rows[0] : null;
          return cb(err, ret);
        };
      })(this)();
      return __iced_it.next();
    };

    Merkled.prototype.write_checkpoint = function(arg, cb) {
      var __iced_it, __iced_passed_deferral, start;
      start = arg.start;
      __iced_passed_deferral = iced.findDeferral(arguments);
      __iced_it = (function(_this) {
        var args, err, q;
        return function*() {
          var __iced_deferrals;
          q = "INSERT INTO merkle_build_checkpoints(seqno,btime,etime) SELECT (IFNULL(MAX(seqno), 0)+1), FROM_UNIXTIME(?), NOW() FROM merkle_build_checkpoints";
          args = [start];
          __iced_deferrals = new iced.Deferrals(__iced_it, {
            parent: __iced_passed_deferral,
            funcname: "Merkled.write_checkpoint"
          });
          mm.db.query({
            q: q,
            args: args
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 494
          }));
          if (__iced_deferrals.await_exit()) {
            yield;
          }
          if (err != null) {
            log.error("Error writing checkpoint: " + err);
          }
          return cb(err);
        };
      })(this)();
      return __iced_it.next();
    };

    Merkled.prototype.find_existing_legacy_uid_root = function(cb) {
      var __iced_it, __iced_passed_deferral;
      __iced_passed_deferral = iced.findDeferral(arguments);
      __iced_it = (function(_this) {
        var args, err, q, ret, row;
        return function*() {
          var __iced_deferrals;
          q = "SELECT hash FROM legacy_uid_tree_root ORDER BY ctime DESC LIMIT 1";
          args = [];
          __iced_deferrals = new iced.Deferrals(__iced_it, {
            parent: __iced_passed_deferral,
            funcname: "Merkled.find_existing_legacy_uid_root"
          });
          mm.db.load_1_or_0({
            q: q,
            args: args
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return row = arguments[1];
              };
            })(),
            lineno: 504
          }));
          if (__iced_deferrals.await_exit()) {
            yield;
          }
          ret = row != null ? row.hash : null;
          log.info("Lookup legacy UID tree root -> " + ret);
          return cb(err, ret);
        };
      })(this)();
      return __iced_it.next();
    };

    Merkled.prototype.build_legacy_uid_tree = function(cb) {
      var __iced_it, __iced_passed_deferral;
      __iced_passed_deferral = iced.findDeferral(arguments);
      __iced_it = (function(_this) {
        var args, esc, list, q, rows, sorted_map, tree, uid, username;
        return function*() {
          var __iced_deferrals, __iced_deferrals1;
          esc = make_esc(cb, "build_legacy_uid_tree");
          log.info("+ Rebuilding legacy UID tree");
          q = "SELECT uid,username FROM users WHERE uid LIKE '%00'";
          args = [];
          __iced_deferrals = new iced.Deferrals(__iced_it, {
            parent: __iced_passed_deferral,
            funcname: "Merkled.build_legacy_uid_tree"
          });
          mm.db.query({
            q: q,
            args: args
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return rows = arguments[0];
              };
            })(),
            lineno: 516
          })));
          if (__iced_deferrals.await_exit()) {
            yield;
          }
          log.info("| Queried DB for username/uid pairs");
          list = (function() {
            var j, len, ref6, results;
            results = [];
            for (j = 0, len = rows.length; j < len; j++) {
              ref6 = rows[j], uid = ref6.uid, username = ref6.username;
              results.push([SHA256(username.toLowerCase(), 'hex'), uid]);
            }
            return results;
          })();
          sorted_map = new merkle.SortedMap({
            list: list
          });
          tree = new LegacyUidTree();
          log.info("| Starting Tree rebuild");
          __iced_deferrals1 = new iced.Deferrals(__iced_it, {
            parent: __iced_passed_deferral,
            funcname: "Merkled.build_legacy_uid_tree"
          });
          tree.build({
            sorted_map: sorted_map
          }, esc(__iced_deferrals1.defer({
            lineno: 522
          })));
          if (__iced_deferrals1.await_exit()) {
            yield;
          }
          log.info("- Rebuilt legacy UID tree");
          return cb(null, tree._root);
        };
      })(this)();
      return __iced_it.next();
    };

    Merkled.prototype.init_legacy_uid_root = function(cb) {
      var __iced_it, __iced_passed_deferral;
      __iced_passed_deferral = iced.findDeferral(arguments);
      __iced_it = (function(_this) {
        var esc, ret;
        return function*() {
          var __iced_deferrals, __iced_deferrals1;
          esc = make_esc(cb, "build_legacy_uid_tree");
          ret = null;
          __iced_deferrals = new iced.Deferrals(__iced_it, {
            parent: __iced_passed_deferral,
            funcname: "Merkled.init_legacy_uid_root"
          });
          _this.find_existing_legacy_uid_root(esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return ret = arguments[0];
              };
            })(),
            lineno: 531
          })));
          if (__iced_deferrals.await_exit()) {
            yield;
          }
          if (ret == null) {
            __iced_deferrals1 = new iced.Deferrals(__iced_it, {
              parent: __iced_passed_deferral,
              funcname: "Merkled.init_legacy_uid_root"
            });
            _this.build_legacy_uid_tree(esc(__iced_deferrals1.defer({
              assign_fn: (function() {
                return function() {
                  return ret = arguments[0];
                };
              })(),
              lineno: 533
            })));
            if (__iced_deferrals1.await_exit()) {
              yield;
            }
          }
          return cb(null, ret);
        };
      })(this)();
      return __iced_it.next();
    };

    Merkled.prototype.start_kbfs_root_loop = function(cb) {
      var __iced_it, __iced_passed_deferral;
      __iced_passed_deferral = iced.findDeferral(arguments);
      __iced_it = (function(_this) {
        var err, error_wait_time_ms, esc, initial_error_wait_time_ms, wait_after_update;
        return function*() {
          var __iced_deferrals, __iced_deferrals1, __iced_deferrals2, results;
          esc = make_esc(cb, "start_kbfs_root_loop");
          if (mm.config.kbfs.mdserver.host == null) {
            log.warn("start_kbfs_root_loop: MDServer not configured. Skipping.");
            cb(null);
            return;
          }
          initial_error_wait_time_ms = 1000;
          error_wait_time_ms = initial_error_wait_time_ms;
          wait_after_update = function(err, cb) {
            var __iced_it, __iced_passed_deferral;
            __iced_passed_deferral = iced.findDeferral(arguments);
            __iced_it = (function(_this) {
              return function*() {
                var __iced_deferrals, __iced_deferrals1;
                if (err != null) {
                  __iced_deferrals = new iced.Deferrals(__iced_it, {
                    parent: __iced_passed_deferral
                  });
                  setTimeout(__iced_deferrals.defer({
                    lineno: 554
                  }), error_wait_time_ms);
                  if (__iced_deferrals.await_exit()) {
                    yield;
                  }
                  error_wait_time_ms *= 2;
                  error_wait_time_ms = Math.min(error_wait_time_ms, mm.config.merkle.kbfs_poll_interval_ms);
                } else {
                  __iced_deferrals1 = new iced.Deferrals(__iced_it, {
                    parent: __iced_passed_deferral
                  });
                  setTimeout(__iced_deferrals1.defer({
                    lineno: 559
                  }), mm.config.merkle.kbfs_poll_interval_ms);
                  if (__iced_deferrals1.await_exit()) {
                    yield;
                  }
                  error_wait_time_ms = initial_error_wait_time_ms;
                }
                return cb(null);
              };
            })(this)();
            return __iced_it.next();
          };
          __iced_deferrals = new iced.Deferrals(__iced_it, {
            parent: __iced_passed_deferral,
            funcname: "Merkled.start_kbfs_root_loop"
          });
          _this.update_kbfs_roots(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 565
          }));
          if (__iced_deferrals.await_exit()) {
            yield;
          }
          cb(null);
          results = [];
          while (true) {
            __iced_deferrals1 = new iced.Deferrals(__iced_it, {
              parent: __iced_passed_deferral,
              funcname: "Merkled.start_kbfs_root_loop"
            });
            wait_after_update(err, __iced_deferrals1.defer({
              lineno: 572
            }));
            if (__iced_deferrals1.await_exit()) {
              yield;
            }
            __iced_deferrals2 = new iced.Deferrals(__iced_it, {
              parent: __iced_passed_deferral,
              funcname: "Merkled.start_kbfs_root_loop"
            });
            _this.update_kbfs_roots(__iced_deferrals2.defer({
              assign_fn: (function() {
                return function() {
                  return err = arguments[0];
                };
              })(),
              lineno: 573
            }));
            if (__iced_deferrals2.await_exit()) {
              yield;
            }
          }
          return results;
        };
      })(this)();
      return __iced_it.next();
    };

    Merkled.prototype.update_kbfs_roots = function(cb) {
      var __iced_it, __iced_passed_deferral;
      __iced_passed_deferral = iced.findDeferral(arguments);
      __iced_it = (function(_this) {
        var cb2, cli, esc, host, open_transport, port, private_arg, private_result, public_arg, public_result, tls_opts, trans;
        return function*() {
          var __iced_deferrals, __iced_deferrals1, ref6;
          log.info("+ update_kbfs_roots");
          open_transport = null;
          cb2 = function(err) {
            if (open_transport != null) {
              open_transport.close();
            }
            if (err != null) {
              log.warn("Error in update_kbfs_roots: " + err);
            }
            log.info("- update_kbfs_roots");
            return cb(err);
          };
          esc = make_esc(cb2, "update_kbfs_roots");
          tls_opts = {
            ca: mm.config.keys.mdserver.ca_cert
          };
          ref6 = mm.config.kbfs.mdserver, host = ref6.host, port = ref6.port;
          trans = new UnwrappingTransport({
            host: host,
            port: port,
            tls_opts: tls_opts
          });
          __iced_deferrals = new iced.Deferrals(__iced_it, {
            parent: __iced_passed_deferral,
            funcname: "Merkled.update_kbfs_roots"
          });
          trans.connect(esc(__iced_deferrals.defer({
            lineno: 595
          })));
          if (__iced_deferrals.await_exit()) {
            yield;
          }
          open_transport = trans;
          cli = new rpc.client.Client(trans, "keybase.1");
          public_arg = {
            treeID: constants.kbfs.merkle_tree_ids.PUBLIC
          };
          private_arg = {
            treeID: constants.kbfs.merkle_tree_ids.PRIVATE
          };
          __iced_deferrals1 = new iced.Deferrals(__iced_it, {
            parent: __iced_passed_deferral,
            funcname: "Merkled.update_kbfs_roots"
          });
          cli.invoke("metadata.getMerkleRootLatest", [public_arg], esc(__iced_deferrals1.defer({
            assign_fn: (function() {
              return function() {
                return public_result = arguments[0];
              };
            })(),
            lineno: 604
          })));
          cli.invoke("metadata.getMerkleRootLatest", [private_arg], esc(__iced_deferrals1.defer({
            assign_fn: (function() {
              return function() {
                return private_result = arguments[0];
              };
            })(),
            lineno: 605
          })));
          if (__iced_deferrals1.await_exit()) {
            yield;
          }
          _this._tree._kbfs["public"].root = public_result.root.toString("base64");
          _this._tree._kbfs["public"].version = public_result.version;
          log.info("updated KBFS public root: " + (JSON.stringify(_this._tree._kbfs["public"])));
          _this._tree._kbfs["private"].root = private_result.root.toString("base64");
          _this._tree._kbfs["private"].version = private_result.version;
          log.info("updated KBFS private root: " + (JSON.stringify(_this._tree._kbfs["private"])));
          return cb2(null);
        };
      })(this)();
      return __iced_it.next();
    };

    Merkled.prototype.full_build = function(cb) {
      var __iced_it, __iced_passed_deferral;
      __iced_passed_deferral = iced.findDeferral(arguments);
      __iced_it = (function(_this) {
        var err, esc, list, prev, sorted_map, start;
        return function*() {
          var __iced_deferrals, __iced_deferrals1, __iced_deferrals2, __iced_deferrals3;
          err = null;
          esc = make_esc(cb, "full_build");
          log.warn("+ full build");
          __iced_deferrals = new iced.Deferrals(__iced_it, {
            parent: __iced_passed_deferral,
            funcname: "Merkled.full_build"
          });
          _this.lookup_previous_checkpoint(esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return prev = arguments[0];
              };
            })(),
            lineno: 620
          })));
          if (__iced_deferrals.await_exit()) {
            yield;
          }
          if (prev != null) {
            log.warn("| Found previous checkpoint: " + (JSON.stringify(prev)) + "; skipping full build");
          } else {
            start = unix_time();
            __iced_deferrals1 = new iced.Deferrals(__iced_it, {
              parent: __iced_passed_deferral,
              funcname: "Merkled.full_build"
            });
            _this.select_all_user_chains_from_db(esc(__iced_deferrals1.defer({
              assign_fn: (function() {
                return function() {
                  return list = arguments[0];
                };
              })(),
              lineno: 625
            })));
            if (__iced_deferrals1.await_exit()) {
              yield;
            }
            log.warn("| selected all user chains " + list.length);
            sorted_map = new merkle.SortedMap({
              list: list
            });
            __iced_deferrals2 = new iced.Deferrals(__iced_it, {
              parent: __iced_passed_deferral,
              funcname: "Merkled.full_build"
            });
            _this._tree.build({
              sorted_map: sorted_map
            }, esc(__iced_deferrals2.defer({
              lineno: 628
            })));
            if (__iced_deferrals2.await_exit()) {
              yield;
            }
            __iced_deferrals3 = new iced.Deferrals(__iced_it, {
              parent: __iced_passed_deferral,
              funcname: "Merkled.full_build"
            });
            _this.write_checkpoint({
              start: start
            }, __iced_deferrals3.defer({
              lineno: 629
            }));
            if (__iced_deferrals3.await_exit()) {
              yield;
            }
          }
          log.warn("- full build");
          return cb(null);
        };
      })(this)();
      return __iced_it.next();
    };

    Merkled.prototype.h_poke = function(arg, cb) {
      var txid;
      txid = arg.txid;
      log.info("Got poke for txid " + txid);
      this.call_tx_wait_cb();
      return cb(null, {});
    };

    return Merkled;

  })(BaseServer);

  UnwrappingTransport = (function(superClass) {
    extend(UnwrappingTransport, superClass);

    function UnwrappingTransport() {
      return UnwrappingTransport.__super__.constructor.apply(this, arguments);
    }

    UnwrappingTransport.prototype.unwrap_incoming_error = function(o) {
      var err, fields;
      if (o == null) {
        return o;
      } else if (typeof o === 'object') {
        switch (o.code) {
          case rpc.errors.UNKNOWN_METHOD:
            err = new rpc.errors.UnknownMethodError(o.message);
            err.method = o.method;
            return err;
          default:
            fields = o.fields != null ? " " + (JSON.stringify(o.fields)) : "";
            return new Error(o.code + " " + o.name + ": " + o.desc + fields);
        }
      } else {
        return new Error(o);
      }
    };

    return UnwrappingTransport;

  })(rpc.transport.Transport);

  run(Merkled, ['config', 'db']);

}).call(this);
